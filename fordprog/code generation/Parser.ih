// Generated by Bisonc++ V5.02.00 on Thu, 06 Apr 2017 02:09:02 +0200

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "Parser.h"
#include <string>

int Parser::label::current = 0;

inline void Parser::error(char const *msg)
{
    std::cerr << "Line " << d_loc__.first_line << ": " << msg << std::endl;
    exit(1);
}

inline std::string Parser::typeToString(type var_type) {
    if(var_type == natural) {
        return "natural";
    }
    if(var_type == boolean) {
        return "boolean";
    }
}

// $insert lex
inline int Parser::lex()
{
    int ret = lexer.yylex();
    d_loc__.first_line = lexer.lineno();
    if( ret == IDENTIFIER || ret == NATURAL_LITERAL )
    {
      d_val__.text = new std::string(lexer.YYText());
    }
    return ret;
}

bool Parser::assertType(const std::string& owner, type expected, type actual) {
    if(expected == actual) {
        return true;
    } else {
        std::stringstream ss;
        ss << "Type mismatch error.\n"
           << "\texpected type: " << typeToString(expected) << "\n"
           << "\tactual type: " << typeToString(actual) << "\n"
           << "\tin " << owner << std::endl;
        error(ss.str().c_str());
        return false;
    }
}

bool Parser::assertType(const std::string& owner, type expected1, type expected2, type actual1, type actual2) {
    return
        assertType("the first parameter of \""+owner+"\"", expected1, actual1)
        && assertType("the second parameter of \""+owner+"\"", expected2, actual2);
}

void Parser::insertSymbol(type var_type, std::string name) {
    if( symbols.count(name) > 0 ) {
        std::stringstream ss;
        ss << "Redeclaration of symbol: " << name << ".\n"
        << "\tFirst declared at line " << symbols[name].decl_row << std::endl;
        error( ss.str().c_str() );
    } else {
        symbols[name] = var_data( d_loc__.first_line, var_type );
    }
}


void Parser::error_undeclared(const std::string& identifier) {
    error(("undefined identifier \"" + identifier + "\"").c_str());
}

std::string Parser::two_param_compare(const expr_desc* left, const expr_desc* right, const std::string& set_type) {
    std::string a = registers::a(size_of(left->expr_type));
    std::string b = registers::b(size_of(left->expr_type));
    std::stringstream ss;
    ss  << right->code
        << "    push eax\n"
        << left->code
        << "    pop ebx\n"
        << "    cmp " << a << ", " << b << "\n"
        << "    " << set_type << " al\n";
    return ss.str();
}

std::string Parser::register_with_size(const std::string& reg_name, int size) {
    if(size == 4) {
        return "e" + reg_name + "x";
    } else if(size == 2) {
        return reg_name + "x";
    } else if(size == 1) {
        return reg_name + "l";
    } else {
        throw;
    }
}


std::string Parser::two_param_expr(const expr_desc* left, const expr_desc* right, const std::string& instruction) {
    std::string a = registers::a(size_of(left->expr_type));
    std::string b = registers::b(size_of(left->expr_type));
    std::stringstream ss;
    ss  << right->code
        << "    push eax\n"
        << left->code
        << "    pop ebx\n"
        << "    " << instruction << "\n";
    return ss.str();
}

std::string Parser::c_function_call(const std::string& function_name, const std::string& param, int size) {
    std::stringstream ss;
    ss  << "    push ebx\n"
        << "    push ecx\n";
    if(param != "") {
        ss << "    push " << param << "\n";
    }
    ss  << "    call " << function_name << "\n";
    if(param != "") {
        ss << "    add esp, " << size << "\n";
    }
    ss  << "    pop ecx\n"
        << "    pop ebx\n";
    return ss.str();
}

int Parser::size_of(type var_type) {
    switch(var_type) {
        case boolean:
            return 1;
            break;
        case natural:
            return 4;
            break;
        default: throw;
    }
}

std::string Parser::asm_size(type var_type) {
    int size = size_of(var_type);
    if(size == 1) {
        return "byte";
    }
    if(size == 2) {
        return "word";
    }
    return "dword";
}

std::string Parser::registers::a(int size) {
    return register_with_size("a", size);
}

std::string Parser::registers::b(int size) {
    return register_with_size("b", size);
}

std::string Parser::registers::c(int size) {
    return register_with_size("c", size);
}

std::string Parser::registers::d(int size) {
    return register_with_size("d", size);
}

std::string Parser::label::get_new() {
    std::stringstream ss;
    ss << "label_" << current++;
    return ss.str();
}


inline void Parser::print()         
{
    print__();           // displays tokens if --print was specified
}

inline void Parser::exceptionHandler__(std::exception const &exc)         
{
    throw;              // re-implement to handle exceptions thrown by actions
}


    // Add here includes that are only required for the compilation 
    // of Parser's sources.



    // UN-comment the next using-declaration if you want to use
    // int Parser's sources symbols from the namespace std without
    // specifying std::

//using namespace std;
