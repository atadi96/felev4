// Generated by Bisonc++ V5.02.00 on Thu, 06 Apr 2017 02:09:02 +0200

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "Parser.h"
#include <string>

inline void Parser::error(char const *msg)
{
    std::cerr << "Line " << d_loc__.first_line << ": " << msg << std::endl;
    exit(1);
}

inline std::string Parser::typeToString(type var_type) {
    if(var_type == natural) {
        return "natural";
    }
    if(var_type == boolean) {
        return "boolean";
    }
}

// $insert lex
inline int Parser::lex()
{
    int ret = lexer.yylex();
    d_loc__.first_line = lexer.lineno();
    if( ret == IDENTIFIER )
    {
      d_val__.szoveg = new std::string(lexer.YYText());
    }
    return ret;
}

bool Parser::assertType(const std::string& owner, type expected, type actual) {
    if(expected == actual) {
        return true;
    } else {
        std::stringstream ss;
        ss << "Type mismatch error.\n"
           << "\texpected type: " << typeToString(expected) << "\n"
           << "\tactual type: " << typeToString(actual) << "\n"
           << "\tin " << owner << std::endl;
        error(ss.str().c_str());
        return false;
    }
}

bool Parser::assertType(const std::string& owner, type expected1, type expected2, type actual1, type actual2) {
    return
        assertType("the first parameter of \""+owner+"\"", expected1, actual1)
        && assertType("the second parameter of \""+owner+"\"", expected2, actual2);
}

void Parser::insertSymbol(type var_type, std::string name) {
    if( symbols.count(name) > 0 ) {
        std::stringstream ss;
        ss << "Redeclaration of symbol: " << name << ".\n"
        << "\tFirst declared at line " << symbols[name].decl_row << std::endl;
        error( ss.str().c_str() );
    } else {
        symbols[name] = var_data( d_loc__.first_line, var_type );
    }
}


void Parser::undeclared(const std::string& identifier) {
    error(("undefined identifier \"" + identifier + "\"").c_str());
}


inline void Parser::print()         
{
    print__();           // displays tokens if --print was specified
}

inline void Parser::exceptionHandler__(std::exception const &exc)         
{
    throw;              // re-implement to handle exceptions thrown by actions
}


    // Add here includes that are only required for the compilation 
    // of Parser's sources.



    // UN-comment the next using-declaration if you want to use
    // int Parser's sources symbols from the namespace std without
    // specifying std::

//using namespace std;
